---
title: "Introducci칩n a @-syntax de Angular | Angular 17 Update"
description: "Primer aproximaci칩n a la nueva sintaxis de Angular y c칩mo busca transformar la experiencia de desarrollo junto con sus beneficios."
draft: false
published: true
tags: ["angular"]
date: 2023-11-09
---

import Tabs from "@components/tabs/Tabs.astro";
import TabItem from "@components/tabs/TabItem.astro";

La versi칩n 17 de Angular ya est치 con nosotros y nos trae una nueva sintaxis llamada @-syntax que mejorar la experiencia de los desarrolladores con el framework. Esta nueva forma de redactar las templates viene a reemplazar los tradicionales `*ngIf, *ngFor, *ngSwitch` y olvidarnos de los elementos `<ng-template>` y `<ng-container>` en nuestras aplicaciones.

Promete simplificar y modernizar la forma en la que trabajamos con Angular e incluso mejorar el rendimiento de nuestra aplicaci칩n. A칰n as칤 tengamos en cuenta que se encuentra en "Developer Preview".

## Ventajas

La nueva @-syntax propone importantes beneficios a tener en cuenta:

- Mejoras en la Legibilidad: La sintaxis es m치s declarativa haciendo m치s facil de entender la l칩gica del template para los desarrolladores.
- Mejora en la eficiencia: Disminuye la cantidad de boilerplate y aprovecha el nuevo sistema de detecci칩n de cambios.
- Soporte para lazy components (`@defer`): Esta nueva adici칩n permite renderizar componentes bajo condiciones especificas.

## Estrucutra condicional @if

Com칰nmente para renderizar condicionalmente un componente u otro en el DOM utilizar칤amos la directiva `*ngIf`. El nuevo `@if` aprovecha el nuevo sistema de detecci칩n de cambios basado en signals para lograr el mismo prop칩sito.

<Tabs>

<TabItem label="@if">

```html
@if (show) {
  <span>Inside if</span>
} @else if (showAnotherIf) {
  <span>Inside else if</span>
} @else {
  <span>Inside else</span>
}
```

</TabItem>

<TabItem label="*ngIf">

```html
<ng-container *ngIf="show; else elseTemplate">
  <span>Inside if</span>
</ng-container>

<ng-template #elseTemplate>
  <ng-container *ngIf="show; else anotherElseTemplate">
    <span>Inside else if</span>
  </ng-container>

  <ng-template #anotherElseTemplate>
    <span>Inside else</span>
  </ng-template>
</ng-template>
```

</TabItem>

<TabItem label="component.ts">

```ts
@Component({
  selector: "some-component",
  standalone: true,
  imports: [CommonModule, RouterOutlet],
  templateUrl: "./some.component.html",
  styleUrls: ["./some.component.scss"],
})
export class SomeComponent {
  show = true;
  showAnotherIf = false;
}
```

</TabItem>

</Tabs>

Esta nueva sintaxis ,al clumplitse la condici칩n, muestra el contenido entre llaves, de lo contrario muestra lo que se encuentra dentro del `@else` o distintos `@else if ()`.

La nueva sintaxis es m치s concisa, legible e igual o m치s flexible que antes. Por otro lado evitamos el uso de `<ng-template>` y `<ng-container>` que, muchas veces, no son tan utilizados por los desarrolladores.

## Estrucutra repetitiva @for

La estructura `@for` reemplaza a la directiva `*ngFor`, permitiendonos renderizar contenido de un arrelgo o iterable. Tambi칠n provee de un nuevo bloque, definido como `@empty`, que ser치 renderizado en caso de que la lista est칠 vac칤a.

<Tabs>

<TabItem label="@for">

```html
<ul>
  @for (user of userList; track user.id; let i = $index){
    <li>{{ i }}. {{ user.name }}</li>
  } @empty {
    <li>Empty array</li>
  }
</ul>
```

</TabItem>

<TabItem label="*ngFor">

```html
<ul>
  <ng-container *ngIf="userList.length; else emptyArray">
    <li *ngFor="let user of userList; index as i">{{i}}. {{ user.name }}</li>
  </ng-container>
  <ng-template #emptyArray>
    <li>Empty array</li>
  </ng-template>
</ul>
```

</TabItem>

<TabItem label="component.ts">

```ts
@Component({
  selector: "some-component",
  standalone: true,
  imports: [CommonModule, RouterOutlet],
  templateUrl: "./some.component.html",
  styleUrls: ["./some.component.scss"],
})
export class SomeComponent {
  userList = [
    { name: "Jhon", id: 1 },
    { name: "Steve", id: 2 },
    { name: "Alex", id: 3 },
  ];
}
```

</TabItem>

</Tabs>

El bloque `@empty` nos facilita renderizar un elemento especial en caso de que el iterable est칠 vac칤o sin la necesidad de agregar un `*ngIf`.

Un punto destacado a mencionar es que ahora `track` es requerido, en este debemos usar id o cualquier otro identificador **칰nico**. Se mantienen las variables impl칤citas de la estructura como: `$index, $first, $last, $even, $odd`

## Estrucutra de control @switch

El bloque `@switch` toma el lugar de `*ngSwitch`, la forma de escribir esta estrucura brinda una clara mejora en la legibilidad y elimina la necesidad de contenedores extra para mantener las expresiones de cada condici칩n.

<Tabs>

<TabItem label="@switch">

```html
@switch (page) {
  @case (1) {
    <p>Viewing content of first page</p>
  }
  @case (2) {
    <p>Viewing content of second page</p>
  }
  @case (3) {
    <p>Viewing content of third page</p>
  }
  @default {
    <p>No page selected</p>
  }
}
```

</TabItem>

<TabItem label="*ngSwitch">

```html
<ng-container [ngSwitch]="page">
  <ng-container *ngSwitchCase="1">
    <p>Viewing content of first page</p>
  </ng-container>
  <ng-container *ngSwitchCase="2">
    <p>Viewing content of second page</p>
  </ng-container>
  <ng-container *ngSwitchCase="3">
    <p>Viewing content of third page</p>
  </ng-container>
  <ng-container *ngSwitchDefault>
    <p>No page selected</p>
  </ng-container>
</ng-container>
```

</TabItem>

<TabItem label="component.ts">

```ts
@Component({
  selector: "some-component",
  standalone: true,
  imports: [CommonModule, RouterOutlet],
  templateUrl: "./some.component.html",
  styleUrls: ["./some.component.scss"],
})
export class SomeComponent {
  page = 2;
}
```

</TabItem>

</Tabs>

## Notas importantes

Por 칰ltimo hay unos puntos importantes a saber con el lanzamiento de Angular 17:

- Las directivas `*ngIf`, `*ngFor`, `*ngSwitch` y los elementos `<ng-template>` y `<ng-container>` no est치n deprecados, siguen siendo soportados por la nueva actualizaci칩n.
- Ambas sintaxis son compatibles entre ellas, es decir, se pueden usar ambas simultaneamente.
- No es solo una nueva sintaxis, sino que trae mejoras en rendimiento, entre un 30% y 90%.
- Hay otro bloque nuevo introducido del que no hice menci칩n llamado `@defer`.
- Existe un comando de Angular CLI que ejecuta la migraci칩n autom치ticamente
  > ```
  > ng g @angular/core:control-flow
  > ```

Las 칰ltimas actualizaciones de Angular est치n cambiando las reglas de juego tradicionales de este framework brindando mejoras significativas y mejorarndo la calidad de desarrollo. 

En lo personal, comenzar un proyecto desde cero en las nuevas versiones de Angular con standalone y @-syntax, se siente distinto 游. El nuevo control flow sencillamente me encanta y le da un toque fresco al framework.

Ahora solo queda por hacer un `ng update`.
